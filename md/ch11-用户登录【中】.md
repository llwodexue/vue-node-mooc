## 登录组件分析

- `src/views/login/index.vue`

**登录组件布局要点如下：**

`el-form` 容器，包含 `username` 和 `password` 两个 `el-form-item`，`el-form` 主要属性：

- `ref` ：用来获取 `el-form` 表单实例

  在表单提交时，通过该实例调用 `validate` 方法

- `model` ：对应 `data` 中的 `loginForm`

- `rules` ：表单的验证项，验证规则主要才是用 `async-validator` 

  详细用法可以查看我这篇文章中的 `async-validator` [Element-UI入门](https://blog.csdn.net/qq_38689395/article/details/120515727)

- `autocomplete` ：自动填充

- `label-position` ：`label` 标签位置

需要修改一下校验规则

```js
const validateUsername = (rule, value, callback) => {
  if (!value || value.length === 0) {
    callback(new Error('请输入正确的用户名'))
  } else {
    callback()
  }
}
const validatePassword = (rule, value, callback) => {
  if (value.length < 4) {
    callback(new Error('密码不能少于4位'))
  } else {
    callback()
  }
}
```

`password` 使用了 `el-tooltip` 提示，当用户打开大小写时，会进行提示，主要属性：

- `manual` ：手动控制模式，设置为 `true` 后，`mouseenter` 和 `mouseleave` 事件将不会生效
- `placement` ：提示出现的位置

![](https://gitee.com/lilyn/pic/raw/master/js-img/login_keyup_native.png)

- 这里绑定 `@keyup` 事件时需要添加 `.native` 修饰符

  如果不添加 `.native` 修饰符，事件会绑定在 `el-input` 组件上

  添加 `.native` 修饰符，事件将绑定到原生的 `input` 标签上

### checkCapslock 方法

`checkCapslock ` 方法只要用途是监听用户键盘输入，显示提示文字的判断逻辑如下：

- 按住 `shift` 时输入小写字符
- 为按住 `shift` 时输入大写字符

```js
checkCapslock({ shiftKey, key } = {}) {
  if (key && key.length === 1) {
    if (shiftKey && (key >= 'a' && key <= 'z') || !shiftKey && (key >= 'A' && key <= 'Z')) {
      this.capsTooltip = true
    } else {
      this.capsTooltip = false
    }
  }
  if (key === 'CapsLock' && this.capsTooltip === true) {
    this.capsTooltip = false
  }
}

// 新版本直接判断key是否是大写
checkCapslock(e) {
  const { key } = e
  this.capsTooltip = key && key.length === 1 && key >= 'A' && key <= 'Z'
}
```

### handleLogin 方法

- 调用 `el-form` 的 `validate` 方法对 `rules` 进行验证
- 如果验证通过，则会调用 `vuex` 的 `user/login`  `action` 进行登录验证
- 登录验证通过后，会重定向到 `redirect` 路由，如果 `redirect` 路由不存在，则直接重定向到 `/` 路由

这里需要注意：由于 `vuex` 中 `user` 指定了 `namespaced` 为 `true`，所以 `dispatch` 时需要加上其命名空间，否则将无法调用 `vuex` 中的 `action`

```js
handleLogin() {
  this.$refs.loginForm.validate(valid => {
    if (valid) {
      this.loading = true
      this.$store.dispatch('user/login', this.loginForm)
        .then(() => {
          this.$router.push({ path: this.redirect || '/', query: this.otherQuery })
          this.loading = false
        })
        .catch(() => {
          this.loading = false
        })
    } else {
      console.log('error submit!!')
      return false
    }
  })
}
```

### user/login 方法

`user/login` 方法调用了 `login API`，传入 `username` 和 `password`，请求成功后会从 `response` 中获取 `token`，然后将 `token` 保存到 `Cookie` 中，之后返回。如果请求失败，将调用 `reject` 方法，将由我们定义的 `request` 模块来处理异常

```js
login({ commit }, userInfo) {
  const { username, password } = userInfo
  return new Promise((resolve, reject) => {
    login({ username: username.trim(), password: password }).then(response => {
      const { data } = response
      commit('SET_TOKEN', data.token)
      setToken(data.token)
      resolve()
    }).catch(error => {
      reject(error)
    })
  })
}
```

`login API` 方法如下：

```js
export function login(data) {
  return request({
    url: '/vue-element-admin/user/login',
    method: 'post',
    data
  })
}
```

这里使用 `request` 方法，它是一个基于 `axios` 封装的库

```js
const service = axios.create({
  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url
  // withCredentials: true, // send cookies when cross-domain requests
  timeout: 5000 // request timeout
})
```

`baseURL` 取的是 `.env.development` 下的变量 `VUE_APP_BASE_API`

```bash
# base api
VUE_APP_BASE_API = '/dev-api'
```

![](https://gitee.com/lilyn/pic/raw/master/js-img/mooc_login_mock.png)

接口是通过 `mock` 实现的，用户数据位于 `/mock/user.js`

## axios 用法分析

- `vue-element-admin`  中`request` 方法使用了 `axios` 的手动实例化方法 `create` 来封装请求

### axios 基本案例

先从一个普通的 `axios` 示例开始：

```js
const url = 'https://127.0.0.1:18081/book/home/v2?openId=1234'
axios.get(url).then(response => {
  console.log(response)
}).catch(err => {
  console.log(err)
})
```

上述代码可以改为：

```js
const url = 'https://127.0.0.1:18081/book/home/v2'
axios.get(url, { 
  params: { openId: '1234' }
}).then(response => {
  console.log(response)
}).catch(err => {
  console.log(err)
})
```

如果我们在请求时需要在 `http` 请求的 `header` 中添加一个 `token`，需要将代码修改为

```js
const url = 'https://127.0.0.1:18081/book/home/v2'
axios.get(url, { 
  params: { openId: '1234' },
  headers: { token: 'abcd' }
}).then(response => {
  console.log(response)
}).catch(err => {
  console.log(err)
})
```

这样改动可以实现我们的需求，但是有两个问题：

- 每次需要传入 `token` 的请求都需要添加 `headers` 对象，会造成大量重复代码
- 每个请求都需要手动定义异常处理，而异常处理逻辑大多是一致的，如果将其封装成通用的异常处理方法，那么每个请求都要调用一遍

### axios.create 示例

```js
const url = '/book/home/v2'
const request = axios.create({
  baseURL: 'https://127.0.0.1:18081',
  timeout: 5000
})
request({
  url, 
  method: 'get',
  params: {
    openId: '1234'
  }
})
```

首先我们通过 `axios.create` 生成一个函数，该函数是 `axios` 实例，通过执行该方法完成请，它与直接调用 `axios.get` 区别如下：

- 需要传入 `url` 参数，`axios.get` 方法的第一个参数是 `url`
- 需要传入 `method` 参数，`axios.get` 方法表示发起 `get` 请求

